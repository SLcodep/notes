# 前端-后端交互的一些概念

## SSR、SSG和CSR


1. **SSR（服务器端渲染）**核心思想**：当用户请求一个页面时，服务器会**实时地**将页面组件和数据渲染成完整的HTML文档，然后发送给浏览器。浏览器收到后可以直接显示内容，之后再加载并执行JavaScript使其具有交互性。**图片象征**：浅蓝色圆圈中的**服务器与电脑，形象地表示了“服务器完成工作，然后将结果交给客户端”。
2. **SSG（静态站点生成）**核心思想**：在**项目构建时**（比如运行 `npm run build`），就提前将页面和数据生成为静态的HTML文件。当用户请求时，服务器直接返回这些预先准备好的文件，速度极快。**图片象征**：粉色圆圈中的**带图表的文档，象征着“预先生成好的、包含数据的静态文件”。
3. **CSR（客户端渲染）**核心思想**：服务器返回一个几乎空的HTML外壳和一个JavaScript文件。浏览器下载并执行JavaScript后，再由JavaScript向API请求数据，并动态地在浏览器中渲染出页面内容。**图片象征**：浅绿色圆圈中的**带图表的电脑屏幕，象征着“渲染工作和数据处理主要在客户端的浏览器中完成”。




# 前后端交互

## 1.必备的通信底层能力

### 1.1HTTP/HTTPS协议

状态码、请求方法(get，post，put等)、请求头/响应头、HTTPS核心(加密、数据劫持)

### 1.2数据格式与序列化/反序列化

**核心格式**：JSON（前后端交互首选）、FormData（文件上传 / 表单提交）

**关键操作**

- **序列化**：前端将 JS 对象转成传输格式（`JSON.stringify()` 转 JSON、`new FormData()` 处理文件）；
- **反序列化**：前端将后端返回的字符串转成 JS 对象（`JSON.parse()` 解析 JSON）；

### 1.3前端请求工具

- **原生方案**：理解 `XMLHttpRequest`（XHR）的核心流程（初始化→打开连接→发送请求→监听响应），但工作中几乎不用原生写，重点是理解原理；


- **现代方案**:fetch API和Axios
  - **核心功能**：设置请求头、传递参数（URL 参数 / 请求体）、处理响应、拦截器（请求拦截：统一加 Token；响应拦截：统一处理错误 / 格式化数据）；
  - **实战场景**：超时设置（`timeout`）、取消请求（如用户切换页面时取消未完成的请求）、重复请求防抖（如避免连续点击提交按钮导致多次请求）。

## 2.进阶必备：解决工作中的核心问题

### 2.1跨域问题

**核心概念**：浏览器的 “同源策略”（协议、域名、端口三者必须一致，否则禁止跨域请求），目的是防止恶意网站窃取数据；

**常见解决方案**：

1.**CORS**（跨域资源共享，最常用）：后端配置 `Access-Control-*` 响应头，前端无需额外代码

2.**前端代理**

```js
// Vite 代理配置
export default defineConfig({
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000', // 后端服务地址
        changeOrigin: true, // 跨域时修改请求头的Origin
        rewrite: (path) => path.replace(/^\/api/, '') // 去掉请求路径中的/api前缀
      }
    }
  }
})
```

### 2.2身份认证与权限控制

#### **2.2.1认证方法：**

**Cookie + Session**：传统方式，前端无需手动处理 Cookie（浏览器自动存储和携带），但需注意跨域 Cookie（需后端配置 `withCredentials`）

**Token认证(主流，如JWT)**：前端登录成功后，后端返回 Token（一串字符串），后续所有请求通过 `Authorization: Bearer ${token}` 头携带 Token；

> - 关键操作：**Token 存储**（`localStorage` **持久化** /`sessionStorage` 会话级）、**过期处理**（响应拦截器捕获 401，跳转登录页或刷新 Token）、**刷新 Token**（用 refresh_token 静默获取新 Token，避免用户重新登录）；

#### 2.2.2**权限控制**

前端需配合后端实现 “**接口级权限**” 和 “**页面级权限**”

- 接口级：请求前判断是否有 Token，无则跳转登录；收到 403 响应时，提示无权限或跳转无权限页面；


- 页面级：根据用户角色（如管理员 / 普通用户）隐藏 / 显示页面元素（如按钮、菜单）。

### 2.3数据缓存策略

**核心目的**：减少重复请求，提升页面加载速度，减轻后端压力；

**常用方案**：

- HTTP 缓存（强缓存 + 协商缓存）：前端无需额外代码，通过后端设置 `Cache-Control`、`ETag`、`Last-Modified` 响应头实现（重点理解 304 状态码的作用）；
- 前端本地缓存：`localStorage`（持久化，如存储用户偏好设置）、`sessionStorage`（会话级，如存储临时表单数据）、`IndexedDB`（大容量数据，如离线应用）；
- 请求缓存：用 Axios 拦截器或 SWR/React Query（下文会讲）缓存接口响应，相同请求再次发起时直接返回缓存数据，同时可配置 “过期时间”“后台刷新”。

## 3.实战提升：适配现代前端工程化的工具与规范

###  3.1现代请求库进阶：SWR/React Query（数据请求 + 缓存一体化）

### 3.2接口请求工程化（大型项目必备）

**接口封装**：统一管理接口地址和请求逻辑，避免重复代码

如统一接口格式，封装**请求 / 响应拦截器统一处理**

### 3.3文件上传 / 下载（高频业务场景）

**文件上传**

- 用 `FormData` 格式传递文件（`Content-Type: multipart/form-data`）；
- 支持单文件 / 多文件上传、进度条（Axios 的 `onUploadProgress` 回调）、断点续传（大文件分割成切片，记录已上传切片，失败后只传未上传部分）；

**文件下载**

普通文件：后端返回文件流，前端用 `blob` 接收，通过 `<a>` 标签下载

大文件：支持分片下载、断点续传（类似上传，记录已下载分片）。

### 3.4实时通信（适配 IM、通知等场景）

## 4.软技能

### 4.1接口文档

- 会看、会用接口文档（如 Swagger/OpenAPI、YApi），明确接口地址、请求方法、参数格式（必填 / 可选）、响应格式、错误码含义；
- 开发前与后端确认接口规范（如参数命名风格：下划线 / 驼峰），避免后期返工。

### 4.2**接口联调技巧**

- 用调试工具：Chrome 开发者工具（Network 面板查看请求 / 响应详情）、Postman（单独测试接口，排除前端 / 后端问题）；
- 联调流程：先让后端提供测试环境接口→用 Postman 验证接口是否正常→前端对接→出现问题时，先看 Network 面板的请求参数 / 响应数据，快速定位是前端传参错误还是后端返回异常。

## 5.能力边界

作为前端开发，**你不需要懂后端的业务逻辑和数据库操作，但必须明确**：

- 「我要传什么」：知道接口需要什么参数（格式、类型、必填项）；
- 「我要怎么传」：选择正确的请求方法、数据格式、认证方式；
- 「我要怎么处理结果」：成功时解析数据渲染页面，失败时给出友好提示；
- 「我要怎么优化」：通过缓存、防抖、重试等提升性能和用户体验；
- 「我要怎么协作」：会看接口文档，能和后端高效联调，定位问题。